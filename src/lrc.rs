// src/lrc.rs

use crate::utils::LRC_TAG_REGEX;
use anyhow::{Context, Result};
use std::fs;
use std::path::{Path, PathBuf};
use std::time::Duration;

pub fn generate_lrc(
    output_path: &Path,
    original_lines: &[String],
    durations: &[Duration],
    chars_per_line: usize,
) -> Result<()> {
    let mut lrc_content = String::new();

    let file_name = output_path.file_stem().unwrap_or_default().to_string_lossy();
    lrc_content.push_str("[ar:Generated by BaiTTS CLI-rs]\n");
    lrc_content.push_str("[al:Audio]\n");
    lrc_content.push_str(&format!("[ti:{}]\n\n", file_name));

    let mut start_times = Vec::with_capacity(original_lines.len() + 1);
    let mut current_time = Duration::from_secs(0);
    start_times.push(current_time);
    for duration in durations {
        current_time += *duration;
        start_times.push(current_time);
    }

    for (i, line) in original_lines.iter().enumerate() {
        let cleaned_line = LRC_TAG_REGEX.replace_all(line, "").trim().to_string();
        if cleaned_line.is_empty() {
            continue;
        }

        let line_start_time = start_times[i];
        let line_end_time = start_times[i + 1];
        let line_duration = line_end_time.saturating_sub(line_start_time);

        let chunks = split_line_intelligently(&cleaned_line, chars_per_line);
        if chunks.is_empty() {
            continue;
        }

        let chunk_duration = line_duration / chunks.len().max(1) as u32;

        for (j, chunk) in chunks.iter().enumerate() {
            let chunk_start_time = line_start_time + chunk_duration * j as u32;
            
            let minutes = chunk_start_time.as_secs() / 60;
            let seconds = chunk_start_time.as_secs() % 60;
            let millis = chunk_start_time.subsec_millis() / 10;

            let timestamp = format!("[{:02}:{:02}.{:02}]", minutes, seconds, millis);
            lrc_content.push_str(&format!("{}{}\n", timestamp, chunk));
        }
    }

    let lrc_path = PathBuf::from(output_path).with_extension("lrc");
    fs::write(&lrc_path, lrc_content)
        .context(format!("无法写入 LRC 文件到 {:?}", lrc_path))?;
    
    println!("成功生成 LRC 文件: {:?}", lrc_path);
    Ok(())
}

/// 检查一个字符是否是理想的断句点（各类标点符号或空格）。
fn is_break_character(c: char) -> bool {
    matches!(c,
        // 中文常用标点 (全角)
        '，' | '。' | '？' | '！' | '；' | '：' | '、' |
        // 英文常用标点 (半角)
        ',' | '.' | '?' | '!' | ';' | ':' |
        // 中文引号和括号 (全角)
        '“' | '”' | '‘' | '’' | '【' | '】' | '（' | '）' | '《' | '》' | '『' | '』' |
        // 英文引号和括号 (半角)
        '\'' | '"' | '(' | ')' | '[' | ']' | '{' | '}' |
        // 空格
        ' '
    )
}

/// 智能地按字符数分割行，避免在行首出现标点符号。
fn split_line_intelligently(line: &str, max_chars: usize) -> Vec<String> {
    if line.chars().count() <= max_chars {
        return vec![line.to_string()];
    }

    let mut chunks = Vec::new();
    let chars: Vec<char> = line.chars().collect();
    let mut current_pos = 0;

    // 循环前，先跳过所有行首的无效字符
    while current_pos < chars.len() && (chars[current_pos].is_whitespace() || is_break_character(chars[current_pos])) {
        current_pos += 1;
    }

    while current_pos < chars.len() {
        if chars.len() - current_pos <= max_chars {
            let chunk = chars[current_pos..].iter().collect::<String>();
            let trimmed_chunk = chunk.trim();
            if !trimmed_chunk.is_empty() {
                 chunks.push(trimmed_chunk.to_string());
            }
            break;
        }

        let search_end = current_pos + max_chars;
        let search_range = &chars[current_pos..search_end];

        if let Some(split_pos_relative) = search_range.iter().rposition(|&c| is_break_character(c)) {
            // 找到了理想的分割点（在max_chars范围内）
            let split_pos_absolute = current_pos + split_pos_relative;
            let chunk = chars[current_pos..=split_pos_absolute].iter().collect::<String>().trim().to_string();
            if !chunk.is_empty() {
                chunks.push(chunk);
            }
            
            let mut next_pos = split_pos_absolute + 1;
            while next_pos < chars.len() && (chars[next_pos].is_whitespace() || is_break_character(chars[next_pos])) {
                next_pos += 1;
            }
            current_pos = next_pos;

        } else {
            // 在max_chars范围内未找到分割点，因此向前查找下一个分割点
            // 从 search_end 开始向字符串末尾搜索
            if let Some(next_break_relative) = chars[search_end..].iter().position(|&c| is_break_character(c)) {
                // 找到了下一个分割点
                let split_pos_absolute = search_end + next_break_relative;
                let chunk = chars[current_pos..=split_pos_absolute].iter().collect::<String>().trim().to_string();
                if !chunk.is_empty() {
                    chunks.push(chunk);
                }

                let mut next_pos = split_pos_absolute + 1;
                while next_pos < chars.len() && (chars[next_pos].is_whitespace() || is_break_character(chars[next_pos])) {
                    next_pos += 1;
                }
                current_pos = next_pos;
            } else {
                // 从 search_end 到字符串末尾都没有任何分割点，将剩余部分全部作为一块
                let chunk = chars[current_pos..].iter().collect::<String>().trim().to_string();
                if !chunk.is_empty() {
                    chunks.push(chunk);
                }
                current_pos = chars.len(); // 结束循环
            }
        }
    }

    chunks
}
