// src/lrc.rs

use crate::utils::LRC_TAG_REGEX;
use anyhow::{Context, Result};
use std::fs;
use std::path::{Path, PathBuf};
use std::time::Duration;

pub fn generate_lrc(
    output_path: &Path,
    original_lines: &[String],
    durations: &[Duration],
    chars_per_line: usize,
) -> Result<()> {
    let mut lrc_content = String::new();

    // 歌词文件最上方添加 LRC 元数据标签
    let file_name = output_path.file_stem().unwrap_or_default().to_string_lossy();
    lrc_content.push_str("[ar:Generated by BaiTTS CLI-rs]\n");
    lrc_content.push_str("[al:Audio]\n");
    lrc_content.push_str(&format!("[ti:{}]\n\n", file_name));

    // 1. 预计算每“整行”的开始时间戳
    let mut start_times = Vec::with_capacity(original_lines.len() + 1);
    let mut current_time = Duration::from_secs(0);
    start_times.push(current_time);
    for duration in durations {
        current_time += *duration;
        start_times.push(current_time);
    }

    // 2. 遍历原始行，处理并分配时间戳
    for (i, line) in original_lines.iter().enumerate() {
        let cleaned_line = LRC_TAG_REGEX.replace_all(line, "").trim().to_string();
        if cleaned_line.is_empty() {
            // 空行不生成歌词，但其时长已正确计入下一行的开始时间
            continue;
        }

        // 获取当前整行的开始时间和结束时间
        let line_start_time = start_times[i];
        let line_end_time = start_times[i + 1]; // [i+1] 是安全的，因为 start_times 比 original_lines 多一个元素
        let line_duration = line_end_time.saturating_sub(line_start_time);

        // 按字符数分割行
        let chunks = split_line_by_char_count(&cleaned_line, chars_per_line);
        if chunks.is_empty() {
            continue;
        }

        // 计算每个拆分后的小行的平均时长
        let chunk_duration = line_duration / chunks.len().max(1) as u32;

        // 为每个小行生成带时间戳的歌词
        for (j, chunk) in chunks.iter().enumerate() {
            let chunk_start_time = line_start_time + chunk_duration * j as u32;
            
            let minutes = chunk_start_time.as_secs() / 60;
            let seconds = chunk_start_time.as_secs() % 60;
            let millis = chunk_start_time.subsec_millis() / 10;

            let timestamp = format!("[{:02}:{:02}.{:02}]", minutes, seconds, millis);
            lrc_content.push_str(&format!("{}{}\n", timestamp, chunk));
        }
    }

    let lrc_path = PathBuf::from(output_path).with_extension("lrc");
    fs::write(&lrc_path, lrc_content)
        .context(format!("无法写入 LRC 文件到 {:?}", lrc_path))?;
    
    println!("成功生成 LRC 文件: {:?}", lrc_path);
    Ok(())
}

fn split_line_by_char_count(line: &str, max_chars: usize) -> Vec<String> {
    let mut result = Vec::new();
    let mut current_chunk = String::new();
    let mut current_len = 0;
    
    let is_punctuation = |c: char| ",.?!;:'\"()[]{}，。？！；：‘’“”（）【】".contains(c);

    for c in line.chars() {
        if current_len >= max_chars && (c.is_whitespace() || is_punctuation(c)) {
            result.push(current_chunk.trim().to_string());
            current_chunk.clear();
            current_len = 0;
        }
        current_chunk.push(c);
        if !is_punctuation(c) {
            current_len += 1;
        }
    }

    if !current_chunk.trim().is_empty() {
        result.push(current_chunk.trim().to_string());
    }

    result
}
